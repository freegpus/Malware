# LLVM Obfuscation

LLVM is a compiler infrastructure. To understand what it is exactly we need to dive into compilation process (this is most accurate for unmanaged code like C/C++).

We can distinguish three steps of assembly generation from the source code:

1. Front end, which includes:
   - scanner, which performs lexical analysis of the code and produces tokens (strings with certain meaning)
   - parser, which produces an abstract syntax tree (tokens grouped in a tree which represents the actual algorithm implemented in the source code)
   - semantic analysis (mainly type checking), during which the AST is checked for errors like wrong use of types or use of variables before initialization
   - generation of intermediate representation, usually based on AST
2. Optimization, which aims at reducing code complexity for example by precalculating stuff. Optimization must not change the algorithm/program itself.
3. Back end, which translates the intermediate representation to expected output (assembly or bytecode).

### Obfuscator-LLVM

We will leverage [`Obfuscator-LLVM`](https://github.com/obfuscator-llvm/obfuscator) project which is an open-source fork of the LLVM.

Obfuscation works on the mentioned intermediate representation (IR) level. In other words it’s a kind of ‘anti’-optimization. `Clang` is used to generate IR from source code, then the IR is processed to obfuscate code flow and finally the assembly is generated.

### Setup

Having gone through the theoretical introduction, let’s prepare the environment for C++ code obfuscation. The Obfuscator-LLVM needs to be downloaded and compiled. The latest branch is `llvm-4.0` (from 2017, the latest version of LLVM is `11.0` nowadays) and the code needs to be compiled with Visual Studio 2017 and not 2019 (as it gives some errors during compilation). We need to use `CMake` to generate VS2017 project and then compile it (minding the target architecture). We can use `Developer Command Prompt for VS 2017` which is a part of Visual Studio 2017:

```
git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator
cd obfuscator
mkdir build
cd build
cmake -G "Visual Studio 15 2017 Win64" ..
```

Note: I had to manually define `ENDIAN_LITTLE`identifier to get rid of some compilation errors.

There are different ways to use `Obfuscator-LLVM` compiler:

- use manually via command line
- add the compiler as a *custom build tool* for `.cpp` and other files in Visual Studio (in a relevant file *Property Pages*)
- use VS Installer to install a `clang-cl` platform toolset and manually swap Visual Studio’s clang version with the compiled compiler [(this kinda sounds like a chicken-egg problem](https://en.wikipedia.org/wiki/Bootstrapping_(compilers))

#### Instructions substitution

This replaces simple arithmetic operations with more complex but equivalent ones. For example: `a = b + c` may be changed to `r = rand(); a = b + r; a = a + c; a = a - r;`. The random value is calculated during the compilation.

It’s possible to apply substitutions multiple times. Random seed from the command line is used to randomly select substitute instruction sequence so this brings some additional uniqueness to the resulting binary.

Let’s add following switches to the compilation command line: `-mllvm -sub -mllvm -sub_loop=5 -mllvm -aesSeed=1234567890ABCDEF1234567890ABCDEF`

#### Bogus control flow

This adds opaque predicates before instruction blocks. An opaque predicate is basically a portion of (prefably random) code which is evaluated at the runtime to a predetermined logical value (`true` or `false`). It is followed by a conditional jump which points to an original instruction block.

This obfuscation can also be applied multiple times, and can target random blocks of code.

Example usage: `-mllvm -bcf -mllvm -bcf_prob=100 -mllvm -bcf_loop=1 -mllvm -aesSeed=1234567890ABCDEF1234567890ABCDEF`

#### Control flow flattening

This one disrupts the sequence of instructions block by placing them on the same level in a looped `switch` statement. Additional variables are defined which actually control the order of execution. 

This obfuscation can also be applied multiple times on.a single block.

Example usage: `-mllvm -fla -mllvm -split -mllvm -aesSeed=1234567890ABCDEF1234567890ABCDEF`





#### Metaprogramming

Metaprogramming is just modifying programs by other programs or by themselves. Turns out that templates are a kind of functional programming language and can be used by compiler to generate source code.

Remember? It’s exactly what we were doing with pre-build scripts - creating a temporary source code with sensitive data obfuscated.

### String obfuscation

Having understood the ability to write code which can be executed by compilers, let’s create a simple string obfuscator which will replace plaintext data with XORed values just before compilation. We would like to use the obfuscation in the following manner: `Obfuscated("secret");`. The `Obfuscated` macro should replace the `"secret"` with a decryption function with an encrypted argument: `Decrypt_runtime(Encrypt_compiletime(secret))`.

To use constant string at compile time, we need to know its exact length. So we will need a compile time function which operates on this length value. So first, we need to create a template which will get an integer as an argument: `template <unsigned int N>`.

Now we will create a struct which holds the obfuscated string (which will replace the plaintext in the source code) and has a compile time function (`constexpr`) as a constructor to obfuscate the plaintext:

```c++
struct Obfuscator
{
	char data[N] = { 0 };
	constexpr Obfuscator(const char* plaintext)
	{
		for (int i = 0; i < N; i++)
		{
			data[i] = plaintext[i] ^ 0x00;
		}
	}
}
```

Now we obfuscate data in source code by creating an `Obfuscator<7>` struct from the `Obfuscator<N>` template (7 = string length + null byte):

```c++
constexpr Obfuscator<7> obfuscated = Obfuscator<7>("secret");
```

To actually use the data in the application we need to decrypt it, so we add deobfuscation function (which operates on a constant value, hence the `const` identifier following its declaration) to the `Obfuscator` template:

```c++
const char* Deobfuscate() const
{
	char plaintext[N] = { 0 };
	for (int i = 0; i < N; i++)
	{
		plaintext[i] = data[i] ^ 0x11;
	}
	return plaintext;
}
```

Now we can deobfuscate the `obfuscated` constant variable: `obfuscated.Deobfuscate()`.

The last thing to do is to create a helper macro which simplifies the obfuscation in the source code. We will use another goodie of `C++11` - lambda functions:

```c++
#define Obfuscated(string) []() -> const char* \
{ \
	constexpr auto secret = Obfuscator<sizeof(string) / sizeof(string[0])>(string); \
	return secret.Deobfuscate(); \
}()
```

Thanks to this string literals appearing in the binary are XOR encrypted. It’s possible to enhance this method to make the application create stack based strings which won’t appear in the `.text` section of PE file.